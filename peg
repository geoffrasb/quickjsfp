# PEG.js grammar



DataDecl = l:DataLeft _  '=' _ r:DataRight {return new Data(l[0],l[1],l[2],r);}
DataLeft = n:Name _ ps:DataParams _ ':' _ t:Type _ {return [n,ps,t];}
DataParams =  &(_ '=') {return []}
      / p:Param _ ps:DataParams {
                ps.unshift(p);
                return ps;
              }
DataRight = !. {return []} 
      / cs:Constructors {return cs}
Constructors = c:Name _ ':' _ ct:Type _ !. {return [new Constructor(c,ct)];}
      /  c:Name _ ':' _ ct:Type _ '|' _ cs:Constructors {
                 cs.unshift(new Constructor(c,ct))
                 return cs;
               }

ModuleDecl = n:Name _ ts:ModParams  {return {name : n, params:ts}}
ModParams = !.            {return [];}
      / n:Name _ ts:ModParams {
              var x = new Type(new ParamType(false,n,new Type(insDontCare)));
              ts.unshift(x);
              return ts;
            }
          / t:Param _ ts:ModParams {
             ts.unshift(t)
             return ts;
            }

Type = ps:TypeParams _ '->' _ t:Type_ {
    if(ps.type.constructor === ArrowType){
      var last = lastArrowOfChain(ps.type);
      last.righttype = new Type(new ArrowType(last.righttype, t));
          return ps;
        }else{
          return new Type(new ArrowType(ps,t));
        }}
     / t:Type_     {return t;}
   / st:SingType {return st;}

Type_ = st:SingType _ '->' _ t:Type_ {return new Type(new ArrowType(st,t));}
    / st:SingType {return st;}

TypeParams = p:Param &(_ '->')   { return p }
     / p:Param _ ps:TypeParams { return new Type(new ArrowType(p,ps)) }
 
Param = '(' _ n:Name _ ':' _ t:Type ')' { 
       return new Type(new ParamType(false,n,t))
        }
    / '{' _ n:Name _ ':' _ t:Type '}' { 
        return new Type(new ParamType(true,n,t))
        }


SingType = p:Param     { return p; }
         / '-' _ t:Type_ { return new Type(new SubType(t)); }
         / '+' _ t:Type_ { return new Type(new SupType(t)); }
         / '(' _ t:Type _ ',' _ ts:TypeTuple _ ')' {
             ts.unshift(t);
             return new Type(new Tuple(ts.length,ts));
           }
         / '(' _ t:Type _ ')' {return t;}
         / r:RecordTypeDecl   {return r;}
         / '[' _ t:Type _ ']' {return new Type(new ListType(t));}
         / '_'     { return new Type(insDontCare); }
         / c:Name [ \t\n\r]+ args:SpaceVals {
             return new Type(new ComposeType(c,args));
           }
         / n:Name  { return new Type(new NameType(n)); }

SpaceVals = ((!.) / (&[)\]}\-])) {return []}
      / s:LongString !. {return [s]}
          / s:LongString [ \t\n\r]+ ss:SpaceVals {
              ss.unshift(s);
              return ss;
            }
LongString = ((!.) / (&[ )\]}\-])) {return ""}
           / s:[^(\[{ )\]}]+ (!. / &[ )\]}\-]) {return s.join('')}
           / s:[^(\[{]* m:FaceLeftPar rp:[)\]}] b:LongString {return s.join('')+m+rp+b}
           
FaceLeftPar = '(' r:SVinP  {return '('+r;}
      / '[' r:SVinSqP {return '['+r;}
            / cb:'{' r:SVinCB {return cb+r;}
SVinP = any:[^)(]* &[(\[{] i:FaceLeftPar ')' b:SVinP
      {return any.join('')+i+')'+b}
      / any:[^)(]* &')'{return any.join('')}
SVinSqP = any:[^\]\[]* &[(\[{] i:FaceLeftPar ']' b:SVinSqP
      {return any.join('')+i+']'+b}
      / any:[^\]\[]* &')'{return any.join('')}
SVinCB = any:[^}{]* &[(\[{] i:FaceLeftPar rcb:'}' b:SVinCB 
      {return any.join('')+i+rcb+b}
      / any:[^}{]* &')'{return any.join('')}

TypeTuple = t:Type &(_ ')') { return [t]; }
      / t:Type _ ',' _ ts:TypeTuple {
              ts.unshift(t);
              return ts;
            }
 
RecordTypeDecl = '{' _ lf:listFields _ '}'  { return new Type(new RecordType(lf))}
listFields = n:Name _ ':' _ t:Type &(_ '}') { return [[n,t]];}
       / ',' _ n:Name _ ':' _ t:Type _ lf:listFields {
              lf.unshift([n,t]);
                return lf;
             }


_ "whitespace"
  = [ \t\n\r]*
Name = n:([a-zA-Z_$][a-zA-Z0-9_$]*) { return new Name(n[0]+n[1].join('')) }
Number = n:([1-9][0-9]*) { return Number(n[0]+n[1].join('')); }
